# IgroupGreedy
# 컴퓨터 알고리즘 2번째 과제

## 1.그리디 알고리즘에 대하여

**Greedy Algorithm**(탐욕법, 탐욕 알고리즘)은 문제를 해결하는 과정에서 그 **순간순간마다 최적**이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다.

[![image](https://besjournals.onlinelibrary.wiley.com/cms/asset/04f4c29c-c548-46d3-8e43-2d6d3ef38db9/jane12963-toc-0001-m.png)](https://besjournals.onlinelibrary.wiley.com/cms/asset/eec59c85-4c34-47b0-b1b4-345eadbc8606/jane12963-toc-0001-m.jpg)

위 그림을 보면 A graph를 Greedy 방법으로는 가장 숫자가 큰 요소를 찾는 데 있어서 해당 분기점마다 보다 큰 수를 찾는 방식으로 최종 해답을 찾아가고 있다. 하지만, optimal(최적) 방법에서 볼 수 있듯이 실제 전체 숫자 중에서  가장 큰 수는 100이다. 이처럼 전체 문제해결에서의 최적의 해답을 찾지는 못한다.

순간순간마다의 최적이 전체 문제에서 최적의 해결책이 되지는 않는다. 하지만, 이러한 단점들을 극복하는 Greedy의 가장 큰 장점은 바로 **계산 속도**이다. 그래서 Greedy 방법이 통하는 몇몇의 문제에서는 최적의 해를 빠르게 찾아낼 수 있다.

그리디 알고리즘은

- 탐욕 선택 속성(greedy choice property)
  - 당장의 상황에서 목표를 위해 가장 도움이 되는 것이라고 할만한 것을 고를 수 있는가?
- 최적 부분 구조(optimal substructure)
  - 부분 문제를 만들 수 있으며 부분 문제의 최적화된 값이 전체 결과까지 최적화된 값을 주는가?

특성을 가지는 문제들을 해결하는 데 강점을 가진다. 즉, 한번의 선택이 다음 선택에는 전혀 무관한 값이여야 하며 매 순간의 최적해가 문제에 대한 최적해여야 한다.

사용되는 예시

- 거스름돈 문제
- 최소 신장 트리 (Minimum spanning tree)
- **다익스트라 알고리즘**
- 크러스컬 알고리즘


## 2. 다익스트라 알고리즘이란?

​	주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단 경로를 찾는 문제를 **최단 경로(Shortest Path) 문제**라고 한다. 최단 경로를 찾는 여러 알고리즘이 있는데 이 중 **다익스트라(Dijkstra) 알고리즘**이 가장 대표적인 알고리즘이라 할 수 있다.

​	다익스트라 알고리즘은 출발점이 주어지고 그 출발점으로부터 최단 거리가 확정되지 않은 점들 중에서 출발점으로부터 가장 가까운 점을 추가하고, 그 점의 최단 거리를 확정하는 알고리즘이다. 단, 이때 간선의 가중치는 음수가 아니여야 한다.


## 3. 설계과정, 수도 코드

**다익스트라(Dijkstra) 알고리즘**을 간단히 설명해보면 아래와 같다.

- 입력 : 가중치 그래프 G, 출발점 s
- 출력 : 출발점 s로부터 (n-1)개의 점까지 각각 최단 거리를 저장한 배열 D

 1. 배열 D[v!=s]=infinite, D[s]=0 으로 초기화시킨다. 

 2. s와 인접한 노드들의 D[v] 값을 갱신한다. (s와 v 간선의 가중치 값으로)

 3. while(s로부터 최단거리가 확정되지 않은 점이 있으면) *: 점이 n개 있다면 n-1번만 수행하면 된다.* {

    현재 s로부터 최단거리가 확정되지 않은 점 v에 대해 최소의 D[v] 값을 가진 점 vmin을 선택하고, 출발점 s로부터 점 vmin까지의 최단거리 D[vmin]을 확정한다.  *(확정한다는 것은 'D[vmin]이 확정된 후에는 다시 변하지 않음'과 '점 vmin이 최단거리 확정 집합에 속함'을 의미한다.)*

 4. s로부터 최단거리가 확정되지 않은 점 중에 vmin을 경유함으로써 s로부터의 거리가 현재보다 더 짧아지는 점 v가 있으면 그 점의 D[v]를 갱신한다.
    }
   
 5. return 배열 D




## 4. 알고리즘의 성능 평가

__<알고리즘 성능 평가>__

+ 알고리즘 성능을 나타내는 척도 (Comlpexity)	
   + 시간복잡도: 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
   + 공간복잡도: 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석
+ 복잡도가 낮을 수록 좋은 알고리즘
  + 시간 복잡도 낮다= 빠르게 실행
  + 공간 복잡도 낮다 = 적은 메모리 사용
+ 빅오 표기법
  + 가장 빠르게 증가하는 항만을 고려하는 표기법
  + 차수가 가장 큰 항만 남김

![빅오 표기법](https://user-images.githubusercontent.com/80510945/113696976-9ed41400-970d-11eb-8f31-b80ea392ef30.png)

다익스트라 고안한 알고리즘으로 처음 고안한 알고리즘은 O(V^2)의 시간복잡도를 가졌다. 이후 *우선순위 큐(=heap tree)* 이용한 더욱 개선된 알고리즘이 나오며, O((V+E)logV) (V는 정점의 개수, E는 한 정점의 주변 노드~~미방문 노드 중 출발점으로부터 현재까지 계산된 최단거리를 가지는 노드를 찾는데 O(VlogV)의 시간이 필요하고, 각 노드마다 이웃한 노드의 최단 거리를 갱신할 때 O(ElogV)의 시간이 필요하기 때문이다.~~)의 시간복잡도를 가지게 되었다. 

5번에서 작성할 코드는 수업시간에 배운 알고리즘을 토대로 빅오표기법으로 O(n^2)의 시간 복잡도를 가지는 코드를 작성할 것이다. while 문에서 n-1번 반복할 때, 배열에서 최소값을 찾는 시간 O(n), 점 n-1 개를 갱신하는 데 걸리는 시간O(n) 즉, 시간 복잡도는 (n-1){O(n)+O(n)}= **O(n^2)** 이다.


## 5. 자바 코드
``` java


```

## 6. 코드 결과
